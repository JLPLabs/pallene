This file describes the adaptations we made to the Lua interpreter.
For the next release, we should consider preparing a proper patch file.

1) Make everything public in the luaconf.h

    #if defined(__GNUC__) && ((__GNUC__*100 + __GNUC_MINOR__) >= 302) && \
        defined(__ELF__)		/* { */
    #define LUAI_FUNC	__attribute__((visibility("internal"))) extern
    #else				/* }{ */
    #define LUAI_FUNC	extern
    #endif				/* } */
    ---
    #define LUAI_FUNC	LUA_API    /* Pallene exports everything */

2) Add the Linker Hack to the lua.c

    /*
    ** PALLENE LINKER HACK
    **
    ** When we build the final "lua" executable, bundling it with the "liblua.a" library, the linker
    ** only includes symbols from the object files where at least one of the symbols of the module is
    ** used by the executable itself. This is a problem for the Pallene runtime library, because those
    ** symbols are only used by extension modules, which we expect to dynamically link. One hacky
    ** workaround I found is to force the "lua" executable to reference one of the symbols from the
    ** pallene_code, as done below.
    */
    char *pallene_tag_name(int);
    char *(*PALLENE_LINKER_HACK)(int) = pallene_tag_name;

3) Copy the pallene_core files

    vm/src/pallene_core.h
    vm/src/pallene_core.c

4) Update the src/Makefile

   - Add pallene_core.o to the CORE_O list
   - Add the pallene_core.o target

    pallene_core.o: pallene_core.c pallene_core.h lapi.h ldo.h lfunc.h \
      lobject.h lstate.h lstring.h ltable.h lvm.h lmem.h lobject.h lstate.h \
      lstring.h ltm.h ltable.h
